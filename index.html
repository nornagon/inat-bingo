<!doctype html>
<style>
.square {
  display: block;
  text-decoration: none;
  position: relative;
}
.square > img {
  display: block;
}
.card {
  display: grid;
  grid-template-columns: repeat(5, min-content);
}
.square label {
  position: absolute;
  bottom: 0;
  width: 100%;
  background: rgba(0, 0, 0, 50%);
  color: white;
  font-family: sans-serif;
  font-size: 14px;
}
web-complete .suggestions {
  position: absolute;
  z-index: 1;
}
web-complete .suggestion {
  display: block;
}
web-complete .active {
  background: blue;
}
</style>
<script type="module" src="https://unpkg.com/web-complete"></script>
<script type="module">
import { h, render } from 'https://unpkg.com/preact@latest?module';
import { useState, useEffect } from 'https://unpkg.com/preact@latest/hooks/dist/hooks.module.js?module';

function mkRandom(seed) {
  return () => {
    return ((seed = seed * 16807 % 2147483647) - 1) / 2147483646
  }
}
function shuffle(rand, array) {
  let currentIndex = array.length,  randomIndex;

  // While there remain elements to shuffle...
  while (currentIndex != 0) {

    // Pick a remaining element...
    randomIndex = Math.floor(rand() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }

  return array;
}

function capitalize(str) {
  return str[0].toUpperCase() + str.substr(1)
}

function capitalizePiece(piece) {
  // \p{Word} matches any word in Unicode, \w does not, apparently
  // https://stackoverflow.com/questions/3576232/how-to-match-unicode-words-with-ruby-1-9#3576559
  let bits

  // Match contractions like d'Silva
  if (bits = /^([a-z]['’])(\w+)/.exec(piece))
    return `${bits[1]}${capitalize(bits[2])}`
  // Match okina and similar leading punctuation characters that will match \p{Word}
  else if (bits = /^([ʻ])(\w+)/.exec(piece))
    return `${bits[1]}${capitalize(bits[2])}`
  else if (bits = /(.*?)(\w+)(.*)/.exec(piece))
    return `${bits[1]}${capitalize(bits[2])}${bits[3]}`
  else
    return piece

}

function capitalizeName(comname) {
  const uncapitalized = [
    "à",
    "a",
    "and",
    "con",
    "da",
    "dal",
    "de",
    "dei",
    "del",
    "des",
    "di",
    "du",
    "e",
    "in",
    "la",
    "o",
    "on",
    "of",
    "the"
  ]
  const comname_pieces = comname.split( /\s+/ )
  return comname_pieces.map((piece, i) => {
    if (i > 0 && uncapitalized.includes( piece.toLowerCase() ))
      return piece.toLowerCase()
    else if (i === comname_pieces.length - 1)
      return piece.split("-").map((s) =>
        uncapitalized.includes(s.toLowerCase())
          ? s.toLowerCase()
          : capitalizePiece(s)
      ).join( "-" )
    else
      return capitalizePiece(piece)
  }).join(" ")
}


function Square({taxon}) {
  return h('a', {class: 'square', href: 'https://inaturalist.org/taxa/' + taxon.id}, [
    h('img', {src: taxon.default_photo.square_url, width: 150, height: 150}),
    h('label', null, taxon.preferred_common_name ? capitalizeName(taxon.preferred_common_name): taxon.name)
  ])
}

const initialLocation = (location.hash.substr(1)|0) || 854

function App() {
  const [date] = useState(new Date)
  const [species, setSpecies] = useState(null)
  const [placeId, setPlaceId] = useState(initialLocation)

  useEffect(() => {
    location.hash = placeId
  }, [placeId])

  useEffect(() => {
    function hashchange() {
      setPlaceId((location.hash.substr(1)|0) || 854)
    }
    window.addEventListener('hashchange', hashchange)
    return () => {
      window.removeEventListener('hashchange', hashchange)
    }
  })

  useEffect(() => {
    const controller = new AbortController();
    const { signal } = controller;
    setSpecies(null)
    fetch(
      `https://api.inaturalist.org/v1/observations/species_counts?verifiable=true&spam=false&place_id=${encodeURIComponent(placeId)}&locale=en-US&preferred_place_id=1&hrank=species&month%5B%5D=${date.getUTCMonth()+1}`,
      { signal }
    ).then(r => r.json()).then(species => {
      const rand = mkRandom(('' + date.getUTCFullYear() + date.getUTCMonth())|0)
      const squares = shuffle(rand, species.results).slice(0, 25)
      setSpecies(squares)
    })
    return () => {
      controller.abort()
    }
  }, [date, placeId])
  return [
    h('web-complete', {
      suggestionGenerator: async (text) => {
        const suggestions = await fetch(
          'https://api.inaturalist.org/v1/places/autocomplete?q='+text
        ).then(x => x.json())
        return suggestions.results.map(r => {
          return {
            text: r.display_name,
            value: r
          }
        })
      },
      maxSuggestions: 10,
      minInput: 2,
      onselected: (e) => {
        console.log(e.detail)
        setPlaceId(e.detail.value.id)
        e.target.querySelector('input').blur()
      }
    }),
    species
      ? species.length
        ? h('div', {class: 'card'},
            species.map(s => h(Square, {taxon: s.taxon})))
        : h('div', null, 'no species')
      : h('div', null, 'loading...')
  ];
}

render(h(App), document.body);
</script>
